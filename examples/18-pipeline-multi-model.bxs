println( "========================================" )
println( "Example 18: Pipelines with Multiple Models" )
println( "========================================" )
println( "" )

result = aiMessage( "Write code to ${task}" )
	.system( "You are a helpful coding assistant, that will write the code and return it ONLY" )
	.toDefaultModel()
	.withName( "coder" )
	.transform( response => { code : response }  ) // Remove if using _input
	.pipe(
		// aiMessage( "Review the provided code: ${_input}" )
		aiMessage( "Review the provided code: ${code}" )
			.toModel( "claude" ).withName( "reviewer" )
	)
	.run( { task: "sort an array of numbers in BoxLang" } )

println( result )
println( "" )

// ============================================================================
// Key Takeaways
// ============================================================================
println( "========================================" )
println( "KEY TAKEAWAYS:" )
println( "========================================" )
println( "1. Pipelines can chain multiple models together" )
println( "2. Use .toModel( modelName ) to specify which model to use" )
println( "3. Each step can have its own system instructions and transformations" )
println( "4. Use .withName() to reference outputs from previous steps" )
println( "5. Complex workflows can be built by chaining models and transformations" )
println( "" )
println( "TIP: Use multiple models to leverage their unique strengths in a single pipeline!" )
